<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="naidem">
<title>Proving the algorithm • naidem</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.2.2/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.2.2/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Proving the algorithm">
<meta property="og:description" content="naidem">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-dark navbar-expand-lg bg-primary"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">naidem</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.1.0.9000</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="active nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-articles">Articles</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-articles">
    <a class="dropdown-item" href="../articles/algorithm.html">Implementing the algorithm</a>
    <a class="dropdown-item" href="../articles/proof.html">Proving the algorithm</a>
  </div>
</li>
      </ul>
<form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off">
</form>

      <ul class="navbar-nav">
<li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/lhdjung/naidem/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>

    
  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="" class="logo" alt=""><h1>Proving the algorithm</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/lhdjung/naidem/blob/HEAD/vignettes/proof.Rmd" class="external-link"><code>vignettes/proof.Rmd</code></a></small>
      <div class="d-none name"><code>proof.Rmd</code></div>
    </div>

    
    
<p>This proof begins with the algorithm for odd lengths and then extends
it to the one for even lenghts.</p>
<p>Each partial algorithm only contains two steps that need to be
proven; all other steps are merely definitional. See <a href="https://lhdjung.github.io/naidem/articles/algorithm.html"><em>Implementing
the algorithm</em></a>, which also contains all definitions used here
except for <code>is_missing(a)</code>. This predicate tests whether the
scalar (length 1) value <code>a</code> is missing.</p>
<div class="section level2">
<h2 id="proof-for-odd-lengths">Proof for odd lengths<a class="anchor" aria-label="anchor" href="#proof-for-odd-lengths"></a>
</h2>
<pre eval="FALSE"><code><span><span class="va">half</span> <span class="op">:=</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">/</span> <span class="fl">2</span> <span class="op">-</span> <span class="fl">0.5</span></span>
<span><span class="va">nna</span> <span class="op">:=</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="fu">keep_missing</span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">)</span></span></code></pre>
<p>The median is the midpoint of the sorted <code>x</code> distribution,
which includes missing values — i.e., <code>x[half]</code> after this
step:</p>
<pre eval="FALSE"><code><span><span class="va">x</span> <span class="op">:=</span> <span class="fu"><a href="https://rdrr.io/r/base/sort.html" class="external-link">sort</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span></code></pre>
<p>Sorted missing observations are still unknown, but the purpose here
is to make some statements about all possible values they might
have:</p>
<pre eval="FALSE"><code><span><span class="va">sorted_na</span> <span class="op">:=</span> <span class="fu">keep_missing</span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span>
<span><span class="va">sorted_known</span> <span class="op">:=</span> <span class="fu">keep_known</span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span></code></pre>
<p>These logical values will be important below. They describe two
possible ways in which <code>x</code> might be ordered — all known
values are less than all missing values, and the reverse:</p>
<pre eval="FALSE"><code><span><span class="va">all_known_values_less</span> <span class="op">:=</span> <span class="va">sorted_known</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">sorted_known</span><span class="op">)</span> <span class="op">-</span> <span class="fl">1</span><span class="op">]</span> <span class="op">&lt;</span> <span class="va">sorted_na</span><span class="op">[</span><span class="fl">0</span><span class="op">]</span></span>
<span><span class="va">all_missing_values_less</span> <span class="op">:=</span> <span class="va">sorted_na</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">sorted_na</span><span class="op">)</span> <span class="op">-</span> <span class="fl">1</span><span class="op">]</span> <span class="op">&lt;</span> <span class="va">sorted_known</span><span class="op">[</span><span class="fl">0</span><span class="op">]</span></span></code></pre>
<div class="section level3">
<h3 id="proof-of-step-3">Proof of step 3<a class="anchor" aria-label="anchor" href="#proof-of-step-3"></a>
</h3>
<p>If there are more missing than known values, the true order of
<code>x</code> might be such that one of the missings is the median.
Even if not, however, there would be no way to know from such data.</p>
<pre eval="FALSE"><code>if nna &gt; half:
    length(sorted_na) &gt; length(sorted_known)
    if all_known_values_less || all_missing_values_less:
        is_missing(x[half])</code></pre>
</div>
<div class="section level3">
<h3 id="proof-of-step-5">Proof of step 5<a class="anchor" aria-label="anchor" href="#proof-of-step-5"></a>
</h3>
<p>Consider two extreme cases:</p>
<ol style="list-style-type: decimal">
<li>All known values are less than all missing values, and thus, the
median is equal to the vector of known values indexed at the midpoint of
the entire input <code>x</code> vector:</li>
</ol>
<pre eval="FALSE"><code>if all_known_values_less:
    x[half] == sorted_known[half]</code></pre>
<ol start="2" style="list-style-type: decimal">
<li>All missing values are less than all known values, and thus, the
median is equal to the vector of known values indexed at the midpoint of
<code>x</code> offset by the number of missing values:</li>
</ol>
<pre eval="FALSE"><code>if all_missing_values_less:
    x[half] == sorted_known[half - nna]</code></pre>
<p>These two points put bounds on the median:</p>
<pre eval="FALSE"><code>sorted_known[half - nna] &lt;= x[half] &lt;= sorted_known[half]</code></pre>
<p>Thus, if they are equal, they are also equal to the median. If the
bounds are not equal, however, either could be the median, in addition
to any values that might exist between them. In this case, there are at
least two different possible medians, which renders the true median
unknown:</p>
<pre eval="FALSE"><code>if sorted_known[half - nna] == sorted_known[half]:
    sorted_known[half] == x[half]
    set possible_medians == { sorted_known[half] }
  else:
    set possible_medians == { sorted_known[half - nna]; ...; sorted_known[half] }</code></pre>
</div>
</div>
<div class="section level2">
<h2 id="proof-for-even-lengths">Proof for even lengths<a class="anchor" aria-label="anchor" href="#proof-for-even-lengths"></a>
</h2>
<p>The definitions are the same as above, except for the fact that there
are two midpoints here:</p>
<pre eval="FALSE"><code><span><span class="va">half_2</span> <span class="op">:=</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span> <span class="op">/</span> <span class="fl">2</span></span>
<span><span class="va">half_1</span> <span class="op">:=</span> <span class="va">half_2</span> <span class="op">-</span> <span class="fl">1</span></span>
<span><span class="va">nna</span> <span class="op">:=</span> <span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="fu">keep_missing</span><span class="op">(</span><span class="va">x</span><span class="op">)</span><span class="op">)</span></span>
<span><span class="va">x</span> <span class="op">:=</span> <span class="fu"><a href="https://rdrr.io/r/base/sort.html" class="external-link">sort</a></span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span>
<span><span class="va">sorted_na</span> <span class="op">:=</span> <span class="fu">keep_missing</span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span>
<span><span class="va">sorted_known</span> <span class="op">:=</span> <span class="fu">keep_known</span><span class="op">(</span><span class="va">x</span><span class="op">)</span></span>
<span><span class="va">all_known_values_less</span> <span class="op">:=</span> <span class="va">sorted_known</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">sorted_known</span><span class="op">)</span> <span class="op">-</span> <span class="fl">1</span><span class="op">]</span> <span class="op">&lt;</span> <span class="va">sorted_na</span><span class="op">[</span><span class="fl">0</span><span class="op">]</span></span>
<span><span class="va">all_missing_values_less</span> <span class="op">:=</span> <span class="va">sorted_na</span><span class="op">[</span><span class="fu"><a href="https://rdrr.io/r/base/length.html" class="external-link">length</a></span><span class="op">(</span><span class="va">sorted_na</span><span class="op">)</span> <span class="op">-</span> <span class="fl">1</span><span class="op">]</span> <span class="op">&lt;</span> <span class="va">sorted_known</span><span class="op">[</span><span class="fl">0</span><span class="op">]</span></span></code></pre>
<p>The target quantity is the mean of these two midpoints:</p>
<pre eval="FALSE"><code><span><span class="op">(</span><span class="va">x</span><span class="op">[</span><span class="va">half_1</span><span class="op">]</span> <span class="op">+</span> <span class="va">x</span><span class="op">[</span><span class="va">half_2</span><span class="op">]</span><span class="op">)</span> <span class="op">/</span> <span class="fl">2</span></span></code></pre>
<div class="section level3">
<h3 id="proof-of-step-4">Proof of step 4<a class="anchor" aria-label="anchor" href="#proof-of-step-4"></a>
</h3>
<p>If more than half of the <code>x</code> values are missing, this
might include <code>half_1</code> or <code>half_2</code>. Either has to
be missing, again assuming that the sequences of known and missing
values don’t alternate. We can’t rule this out, so it’s unknown whether
it’s the case. Since it is unknown whether at least one of
<code>half_1</code> and <code>half_2</code> is missing, it is not
possible to determine both of them. Therefore, the median is unknown as
well, since <code>half_1</code> and <code>half_2</code> jointly form the
basis for computing it:</p>
<pre eval="FALSE"><code>if nna &gt; half_1:
    length(sorted_na) &gt; length(sorted_known)
    if all_known_values_less || all_missing_values_less:
        is_missing(x[half_1]) || is_missing(x[half_2])
        is_missing((x[half_1] + x[half_2]) / 2)</code></pre>
</div>
<div class="section level3">
<h3 id="proof-of-step-6">Proof of step 6<a class="anchor" aria-label="anchor" href="#proof-of-step-6"></a>
</h3>
<p>Analogous to case (1) in the proof for odd lengths:</p>
<pre eval="FALSE"><code>if all_known_values_less:
    x[half_1] == sorted_known[half_1]
    x[half_2] == sorted_known[half_2]</code></pre>
<p>Analogous to case (2):</p>
<pre eval="FALSE"><code>if all_missing_values_less:
    x[half_1] == sorted_known[half_1 - nna]
    x[half_2] == sorted_known[half_2 - nna]</code></pre>
<p>As in the previous proof, the extremes put bounds on the
midpoints:</p>
<pre eval="FALSE"><code>sorted_known[half_1 - nna] &lt;= x[half_1] &lt;= sorted_known[half_1]
sorted_known[half_2 - nna] &lt;= x[half_2] &lt;= sorted_known[half_2]</code></pre>
<p>Both pairs of extremes need to be equal, or else there are at least
two possible medians, and the true median is unknown:</p>
<pre eval="FALSE"><code>if sorted_known[half_1 - nna] == sorted_known[half_1] &amp;&amp;
   sorted_known[half_2 - nna] == sorted_known[half_2]:
      (sorted_known[half_1] + sorted_known[half_2]) / 2 == (x[half_1] + x[half_2]) / 2
      set possible_medians == { (sorted_known[half_1] + sorted_known[half_2]) / 2 }
   else:
      set possible_medians == { 
        (sorted_known[half_1 - nna] + sorted_known[half_2 - nna]) / 2;
        ...;
        (sorted_known[half_1] + sorted_known[half_2]) / 2
      }</code></pre>
<p>This can be simplified:</p>
<pre eval="FALSE"><code># Two general reminders:
nna &gt; 0
sorted_known[half_2 - 1] == sorted_known[half_1]

if sorted_known[half_1 - nna] == sorted_known[half_1] &amp;&amp;
   sorted_known[half_2 - nna] == sorted_known[half_2]:
     # Is this possible?
     if sorted_known[half_1] != sorted_known[half_2]:
          sorted_known[half_2 - 1] != sorted_known[half_2]
          # It isn't, because the median would then depend
          # on the missing values' position within
          # the rank order:
          if all_known_values_less:
               x[half_1] &lt; (x[half_1] + x[half_2]) / 2 &lt; x[half_2]
          if all_missing_values_less:
               x[half_1] &lt;= (x[half_1] + x[half_2]) / 2 &lt;= x[half_2]</code></pre>
<p>As a consequence, more than one value is possible for each of
<code>x[half_1]</code> and <code>x[half_2]</code> given the missing
values. This, in turn, contradicts the basic premise that each of the
two values around the median remains equal when offset by
<code>nna</code>. If this premise is false, however, the median cannot
be determined, as shown above. This is why <code>half_1</code> and
<code>half_2</code> must be equal in order for the median to be
determined, and since the mean of two equal values is equal to each of
them, the median is equal to both <code>x[half_1]</code> and
<code>x[half_2]</code>.</p>
<p>If the median of an even-length distribution with missing values can
be determined at all, the algorithm can simply return
<code>x[half_1]</code> instead of
<code>(x[half_1] + x[half_2]) / 2</code>. Simplifying the algorithm in
this way makes it more efficient.</p>
</div>
</div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p></p>
<p>Developed by Lukas Jung.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

    </footer>
</div>

  

  

  </body>
</html>
