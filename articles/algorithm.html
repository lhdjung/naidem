<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="description" content="naidem">
<title>Implementing the algorithm • naidem</title>
<script src="../deps/jquery-3.6.0/jquery-3.6.0.min.js"></script><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<link href="../deps/bootstrap-5.2.2/bootstrap.min.css" rel="stylesheet">
<script src="../deps/bootstrap-5.2.2/bootstrap.bundle.min.js"></script><!-- Font Awesome icons --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous">
<!-- bootstrap-toc --><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@v1.0.1/dist/bootstrap-toc.min.js" integrity="sha256-4veVQbu7//Lk5TSmc7YV48MxtMy98e26cf5MrgZYnwo=" crossorigin="anonymous"></script><!-- headroom.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script><!-- clipboard.js --><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script><!-- search --><script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/6.4.6/fuse.js" integrity="sha512-zv6Ywkjyktsohkbp9bb45V6tEMoWhzFzXis+LrMehmJZZSys19Yxf1dopHx7WzIKxr5tK2dVcYmaCk2uqdjF4A==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/autocomplete.js/0.38.0/autocomplete.jquery.min.js" integrity="sha512-GU9ayf+66Xx2TmpxqJpliWbT5PiGYxpaG8rfnBEk1LL8l1KGkRShhngwdXK1UgqhAzWpZHSiYPc09/NwDQIGyg==" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/mark.min.js" integrity="sha512-5CYOlHXGh6QpOFA/TeTylKLWfB3ftPsde7AnmhuitiTX4K5SqCLBeKro6sPS8ilsz1Q4NRx3v8Ko2IBiszzdww==" crossorigin="anonymous"></script><!-- pkgdown --><script src="../pkgdown.js"></script><meta property="og:title" content="Implementing the algorithm">
<meta property="og:description" content="naidem">
<!-- mathjax --><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <a href="#main" class="visually-hidden-focusable">Skip to contents</a>
    

    <nav class="navbar fixed-top navbar-dark navbar-expand-lg bg-primary"><div class="container">
    
    <a class="navbar-brand me-2" href="../index.html">naidem</a>

    <small class="nav-text text-muted me-auto" data-bs-toggle="tooltip" data-bs-placement="bottom" title="">0.1.0.9000</small>

    
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div id="navbar" class="collapse navbar-collapse ms-3">
      <ul class="navbar-nav me-auto">
<li class="nav-item">
  <a class="nav-link" href="../reference/index.html">Reference</a>
</li>
<li class="active nav-item dropdown">
  <a href="#" class="nav-link dropdown-toggle" data-bs-toggle="dropdown" role="button" aria-expanded="false" aria-haspopup="true" id="dropdown-articles">Articles</a>
  <div class="dropdown-menu" aria-labelledby="dropdown-articles">
    <a class="dropdown-item" href="../articles/algorithm.html">Implementing the algorithm</a>
    <a class="dropdown-item" href="../articles/proof.html">Proving the algorithm</a>
  </div>
</li>
      </ul>
<form class="form-inline my-2 my-lg-0" role="search">
        <input type="search" class="form-control me-sm-2" aria-label="Toggle navigation" name="search-input" data-search-index="../search.json" id="search-input" placeholder="Search for" autocomplete="off">
</form>

      <ul class="navbar-nav">
<li class="nav-item">
  <a class="external-link nav-link" href="https://github.com/lhdjung/naidem/" aria-label="github">
    <span class="fab fa fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
</div>

    
  </div>
</nav><div class="container template-article">




<div class="row">
  <main id="main" class="col-md-9"><div class="page-header">
      <img src="" class="logo" alt=""><h1>Implementing the algorithm</h1>
            
      
      <small class="dont-index">Source: <a href="https://github.com/lhdjung/naidem/blob/HEAD/vignettes/algorithm.Rmd" class="external-link"><code>vignettes/algorithm.Rmd</code></a></small>
      <div class="d-none name"><code>algorithm.Rmd</code></div>
    </div>

    
    
<p>Follow these steps to implement naidem’s median algorithm in another
language. It is tailored to numeric distributions in which some values
are missing. For a proof, see <a href="https://lhdjung.github.io/naidem/articles/proof.html"><em>Proving
the algorithm</em></a>.</p>
<p>This article uses pseudo-code to present two distinct algorithms for
distributions of odd and even length (i.e., number of values). The R
implementation, i.e., the default method for <code><a href="../reference/median2.html">median2()</a></code>,
condenses both into one. That is because vectorization in R allows for
code that deemphasizes the difference in length. Other languages may
need more explicit distinctions. However, it is of course possible to
combine the two algorithms into a single one that first checks whether
the length is even or odd.</p>
<p>Below, <code>x</code> is the input distribution.
<code>length(d)</code> computes the number of values in a distribution
<code>d</code>, <code>sort(d)</code> is a sorting algorithm,
<code>keep_missing(d)</code> returns all missing values in
<code>d</code> (but no known values), and <code>keep_known(d)</code> is
the opposite. <code>NA</code> denotes a single missing value. Unlike R,
these algorithms use zero-indexing. Step 1 of the algorithm for odd
lengths is therefore equivalent to integer division for such
distributions.</p>
<div class="section level2">
<h2 id="for-odd-length-distributions">For odd-length distributions<a class="anchor" aria-label="anchor" href="#for-odd-length-distributions"></a>
</h2>
<pre eval="FALSE"><code># 1. Determine the central index of `x`.
half := length(x) / 2 - 0.5

# 2. Count the missing values in `x`.
nna := length(keep_missing(x))

# 3. If the offset index is negative,
# the median cannot be determined.
if nna &gt; half:
   return NA

# 4. Remove all missing values from `x`, then sort `x`.
x := sort(keep_known(x))

# 5. Check values at two specific indices for equality.
# If they are equal, return the central `x` value, i.e.,
# the median. If they are not equal, return a missing value.
if x[half - nna] == x[half]:
   return x[half]
else:
   return NA</code></pre>
</div>
<div class="section level2">
<h2 id="for-even-length-distributions">For even-length distributions<a class="anchor" aria-label="anchor" href="#for-even-length-distributions"></a>
</h2>
<pre eval="FALSE"><code># 1. Determine the upper central index of `x`.
half_2 := length(x) / 2

# 2. Determine the lower central index.
half_1 := half_2 - 1

# 3. Count the missing values in `x`.
nna := length(keep_missing(x))

# 4. Neither offset index can be negative.
# If any is, the median cannot be determined.
if nna &gt; half_1:
   return NA

# 5. Remove all missing values from `x`, then sort `x`.
x := sort(keep_known(x))

# 6. Check whether both pairs are equal.
# If they are, return the mean of the central values.
# If one or both are not equal, return a missing value.
if x[half_1 - nna] == x[half_1] &amp;&amp; x[half_2 - nna] == x[half_2]:
   return (x[half_1] + x[half_2]) / 2
else:
   return NA</code></pre>
</div>
<div class="section level2">
<h2 id="explanation">Explanation<a class="anchor" aria-label="anchor" href="#explanation"></a>
</h2>
<p>Missing values may or may not make it impossible to determine the
median. Implementations of the median should check whether they do for
any given distribution, instead of simply assuming that they do every
time.</p>
<p>The algorithms check whether the putative median can be changed by a
shift due to missing values. If so, the median depends on the position
of the missing values in the sorted distribution — and thus, on their
values. Since these are unknown, the median cannot be determined.
However, if the median remains the same after the shift, it is
indifferent to the missing values: the median is identical for all
possible values behind the missing ones. See <a href="https://lhdjung.github.io/naidem/articles/proof.html"><em>Proving
the algorithm</em></a> for details.</p>
<p>Subtraction is used for the shift because <code>x</code> is still
indexed at <code>half</code> (the midpoint of the input <code>x</code>)
even though all missing values were already removed from <code>x</code>
by that point. Therefore, <code>x[half]</code> is not actually the
midpoint of <code>x</code>. The maximum possible number of steps by
which missing values can shift the median is <code>nna</code>, so this
number is subtracted.</p>
<p>It is generally easier to determine the median for distributions of
an odd length. The same is true when missing values are present. The
even-length algorithm operates with two central indices instead of one
because even-length distributions don’t have a single central value. The
algorithm needs to compare <code>x</code> at each of these indices with
the respective index offset by the number of missing values. In this
way, it effectively checks whether the pair of <code>x</code> values at
the central indices in the offset case is equal to the pair without the
offset. The odd-length algorithm just checks two single values for
equality.</p>
<p>The algorithms return <code>NA</code> if any offset central index is
negative, i.e., if <code>half(_1) - nna &lt; 0</code>. (This is step 3
for odd lengths and step 4 for even lengths. The pseudo-code in the
algorithm is more efficient.) In the even-length case, only
<code>half_1</code> needs to be tested because it is less than
<code>half_2</code>, so it is negative whenever <code>half_2</code> is.
Why return <code>NA</code> here? The median is never known in such
cases, and indices must not be negative when testing for equality in the
final condition. Negative indices are not well defined, and programming
languages such as R and Python would handle them in unintended ways.</p>
</div>
<div class="section level2">
<h2 id="r-details">R details<a class="anchor" aria-label="anchor" href="#r-details"></a>
</h2>
<p>The R implementation in naidem is more succinct than the pseudo-code.
This plays into the strengths of R, but it does make the code look a
little different from the above. Again, note that the pseudo-code uses
zero-indexing but R uses one-indexing. This is why
<code>any(nna + 1L &gt; half)</code> checks for non-positive indices in
general, not just for negative ones.</p>
<p>The final condition checks whether the possible medians are
<em>not</em> equal, and as a consequence, the function returns a missing
value if the condition is <code>TRUE</code>. The reason is that the R
code combines both algorithms into one, and if the negation returns
<code>FALSE</code>, the median can be determined but the code still
needs to check whether <code>x</code> was originally even or odd. To do
so, it uses the <code>half</code> vector which has length 1 if
<code>x</code> was odd and length 2 if <code>x</code> was even.</p>
<p>Similarly, the condition is wrapped into <code>isTRUE(all(.))</code>,
so that <code><a href="https://rdrr.io/r/base/all.html" class="external-link">all()</a></code> reduces two Boolean test results to one if
the input has an even length. If this returns <code>NA</code>, the
<code><a href="https://rdrr.io/r/base/Logic.html" class="external-link">isTRUE()</a></code> wrapping returns <code>FALSE</code> so that the
negation returns <code>TRUE</code> whenever any comparison between the
possible median values returns either <code>NA</code> or
<code>FALSE</code>. Since the median is unknown in this case, the
function ultimately returns <code>NA</code>.</p>
<p>If this doesn’t occur and <code>x</code> was originally even, the
code uses <code><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean()</a></code> instead of manually dividing the sum of
the half-indexed <code>x</code> values by 2. That is because some
classes may have specific <code><a href="https://rdrr.io/r/base/mean.html" class="external-link">mean()</a></code> methods implemented.
Compare this to the details section of the documentation for
<code><a href="https://rdrr.io/r/stats/median.html" class="external-link">stats::median()</a></code>.</p>
</div>
  </main><aside class="col-md-3"><nav id="toc"><h2>On this page</h2>
    </nav></aside>
</div>



    <footer><div class="pkgdown-footer-left">
  <p></p>
<p>Developed by Lukas Jung.</p>
</div>

<div class="pkgdown-footer-right">
  <p></p>
<p>Site built with <a href="https://pkgdown.r-lib.org/" class="external-link">pkgdown</a> 2.0.7.</p>
</div>

    </footer>
</div>

  

  

  </body>
</html>
